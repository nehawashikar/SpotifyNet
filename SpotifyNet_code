# -*- coding: utf-8 -*-
"""176_Final_Project_Code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q1wLqKXfXBzgtCZ6Jv4lJqZP65DEYOn9
"""

import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt

# Initialize the graph using the pairs.tsv file.
# pairs.tsv contains undirected edges in the format: artist_one[tab]artist_two[tab]weight
G = nx.read_weighted_edgelist('pairs.tsv', delimiter='\t')

# Create a dataframe using the artists.tsv file.
# artists.tsv contains artist data in the format: id[tab]name[tab]genres[tab]popularity
artists = pd.read_csv('artists.tsv', delimiter='\t')

# Print # of Nodes and Edges
print("Number of Nodes:", G.number_of_nodes())
print("Number of Edges:", G.number_of_edges())

# Print # of connected components
print("Number of connected components:", nx.number_connected_components(G))

# Print the diameter
diameter = max([max(j.values()) for (i,j) in nx.shortest_path_length(G)])
print("Diameter:", diameter)

# Get node labels
labels = {}
for n in G.nodes:
  # Use the artists dataframe to map artist id to name
  labels[n] = artists.loc[artists['id'] == n].values[0][1].replace("$$", "\$\$")

# Generate a spring layout
pos = nx.spring_layout(G)

# Get the n-highest values of a dictionary
def top_n(data, count):

  # Sort the data
  top = dict(sorted(data.items(), key = lambda x: x[1], reverse = True)[:count])

  # Generate the output list
  out = [(labels[k], k, top[k]) for k in top]
  return out

import statistics as stats

# Print the top 20, average, and median for a dataset
def print_key_stats(name, data_dict, data_list):
  print(f"Top 20 {name}: {top_n(data_dict, 20)}")
  print(f"Average {name}: {stats.mean(data_list)}")
  print(f"Median {name}: {stats.median(data_list)}")
  print()


# Degree Centrality
degree_dict = nx.degree_centrality(G)
degree_list = [degree_dict.get(k) for k in degree_dict]
print_key_stats("Degree Centrality", degree_dict, degree_list)

# Closeness Centrality
closeness_dict = nx.closeness_centrality(G)
closeness_list = [closeness_dict.get(k) for k in closeness_dict]
print_key_stats("Closeness Centrality", closeness_dict, closeness_list)

# Betweenness Centrality
betweenness_dict = nx.betweenness_centrality(G)
betweenness_list = [betweenness_dict.get(k) for k in betweenness_dict]
print_key_stats("Betweenness Centrality", betweenness_dict, betweenness_list)

# Eigenvector Centrality
eigenvector_dict = nx.eigenvector_centrality(G)
eigenvector_list = [eigenvector_dict.get(k) for k in eigenvector_dict]
print_key_stats("Eigenvector Centrality", eigenvector_dict, eigenvector_list)

# Clustering Coefficient
clustering_dict = nx.clustering(G)
clustering_list = [clustering_dict.get(k) for k in clustering_dict]
print_key_stats("Clustering Coefficient", clustering_dict, clustering_list)

# Get the top 5 nodes for each centrality
top_5_degree = [k[1] for k in top_n(degree_dict, 5)]
top_5_closeness = [k[1] for k in top_n(closeness_dict, 5)]
top_5_betweenness = [k[1] for k in top_n(betweenness_dict, 5)]
top_5_eigenvector = [k[1] for k in top_n(eigenvector_dict, 5)]

# Draw the graph with the to 5 nodes for each centrality highlighted
nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["green"])
nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["red"], nodelist=top_5_degree)
plt.title("Top 5 Degree")
plt.show()

nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["green"])
nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["red"], nodelist=top_5_closeness)
plt.title("Top 5 Closeness")
plt.show()

nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["green"])
nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["red"], nodelist=top_5_betweenness)
plt.title("Top 5 Betweenness")
plt.show()

nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["green"])
nx.draw(G, pos=pos, with_labels=False, node_size=5, node_color=["red"], nodelist=top_5_eigenvector)
plt.title("Top 5 Eigenvector")
plt.show()

# Set color to red if node has clustering coefficient of 1, otherwise green
cc_is_one = [n for n in G.nodes if clustering_dict[n] == 1.0]
cc_not_one = [n for n in G.nodes if n not in cc_is_one]
print(f"{len(cc_is_one)} nodes have a clustering coefficient of 1")

# nx.draw_networkx(G, pos=pos, with_labels=False, node_size=5, node_color=[(0, 0.5, 0)], nodelist=cc_not_one)
# nx.draw_networkx(G, pos=pos, with_labels=False, node_size=5, node_color=[(1, 0, 0)], nodelist=cc_is_one)
# plt.show()

nx.draw_networkx(G, pos=pos, with_labels=True, labels=labels, font_size=4, node_size=20)

# Kamada Kawai
# nx.draw(G, with_labels=False, pos=nx.kamada_kawai_layout(G), node_size=5)
# plt.title("kamada_kawai")
# plt.show()

# Fruchterman Reingold
fruchterman_reingold = nx.fruchterman_reingold_layout(G)
nx.draw(G, with_labels=False, pos=fruchterman_reingold, node_size=5)
plt.title("fruchterman_reingold")
plt.show()

# Circular
circular = nx.circular_layout(G)
nx.draw(G, with_labels=False, pos=circular, node_size=5)
plt.title("circular")
plt.show()

# Random
random = nx.random_layout(G)
nx.draw(G, with_labels=False, pos=random, node_size=5)
plt.title("random")
plt.show()

# Spectral
# spectral = nx.spectral_layout(G)
# nx.draw(G, with_labels=False, pos=spectral, node_size=5)
# plt.title("spectral")
# plt.show()

# Spring
spring = nx.spring_layout(G)
nx.draw(G, with_labels=False, pos=spring, node_size=5)
plt.title("spring")
plt.show()

# Filter out artists without specific genres
artists_with_genres = artists[artists['genres'].notnull()]

# Construct a dict mapping genre to # of artists making music within that genre
genres = {}
for i, row in artists_with_genres.iterrows():
  for genre in row["genres"].split(","):
    genre = genre.replace(" ", "_")
    if not genre in genres:
      genres[genre] = 0
    genres[genre] += 1

# Print top 20 genres
top = dict(sorted(genres.items(), key = lambda x: x[1], reverse = True)[:20])
for k in top:
  print(f"{k}: {top[k]}")

connected_components = nx.connected_components(G)

# Sort and print connected components
sorted_cc = sorted(connected_components, key=len, reverse=True)
print(f"connected components: {sorted_cc}")

# Print number of components
print(f"# of components: {len(sorted_cc)}")

# Print names of artists of Connected Component
for component in sorted_cc:
  print([labels[k] for k in component])

# Find the Giant Connected Component
GCC = G.subgraph(max(nx.connected_components(G), key=len))

# Print size of GCC
print(f"Size of GCC: {len(GCC.nodes)}")

# Draw the graph
nx.draw_networkx(G, pos=pos, with_labels=False, node_size=5)
plt.title("Original")
plt.show()

# Draw the GCC
nx.draw_networkx(GCC, pos=pos, with_labels=False, node_size=5)
plt.title("GCC")
plt.show()

import networkx.algorithms.community as nx_comm

# Get node color
def get_color(i, r_off=1, g_off=1, b_off=1):
    n = 16
    low, high = 0.1, 0.9
    span = high - low
    r = low + span * (((i + r_off) * 3) % n) / (n - 1)
    g = low + span * (((i + g_off) * 5) % n) / (n - 1)
    b = low + span * (((i + b_off) * 7) % n) / (n - 1)
    return (r, g, b)

# Set node communities
def set_node_community(G, communities):
    '''Add community to node attributes'''
    for c, v_c in enumerate(communities):
        for v in v_c:
            G.nodes[v]['community'] = c + 1

# Set edge communities
def set_edge_community(G):
    '''Find internal edges and add their community to their attributes'''
    for v, w, in G.edges:
        if G.nodes[v]['community'] == G.nodes[w]['community']:
            G.edges[v, w]['community'] = G.nodes[v]['community']
        else:
            G.edges[v, w]['community'] = 0

# Get the communities
partition=nx_comm.louvain_communities(G, seed=123)

# Print key statistics
print("# of communities: ", len(partition), ", modularity score: ", nx_comm.modularity(G, partition))

# Set node and edge communities
set_node_community(G, partition)
set_edge_community(G)

# Set community color for nodes
node_color = [get_color(G.nodes[v]['community']) for v in G.nodes]

# Set community color for internal edges
external = [(v, w) for v, w in G.edges if G.edges[v, w]['community'] == 0]
internal = [(v, w) for v, w in G.edges if G.edges[v, w]['community'] > 0]
internal_color = [get_color(G.edges[e]['community']) for e in internal]

# Show Louvain visualization
nx.draw_networkx(G, pos=pos, with_labels=False, node_size=0, edgelist=external, edge_color="#404040")
nx.draw_networkx(G, pos=pos, with_labels=False, node_size=5, node_color=node_color, edgelist=internal, edge_color=internal_color)
plt.title("Louvain")
plt.show()

# Get the communities
communities = nx_comm.girvan_newman(G)

# Map the communities to node groups
partition = []
for com in next(communities):
    partition.append(list(com))

# Print key statistics
print(f"# of communities: {len(partition)}, modularity score: {nx_comm.modularity(G, partition)}")

# Set the node and edge communities
set_node_community(G, partition)
set_edge_community(G)

# Set community color for nodes
node_color = [get_color(G.nodes[v]['community']) for v in G.nodes]

# Set community color for internal edges
external = [(v, w) for v, w in G.edges if G.edges[v, w]['community'] == 0]
internal = [(v, w) for v, w in G.edges if G.edges[v, w]['community'] > 0]
internal_color = [get_color(G.edges[e]['community']) for e in internal]

# Show Girvan-Newman visualization
nx.draw_networkx(G, pos=pos, with_labels=False, node_size=0, edgelist=external, edge_color="#404040")
nx.draw_networkx(G, pos=pos, with_labels=False, node_size=5, node_color=node_color, edgelist=internal, edge_color=internal_color)
plt.title("Girvan-Newman")
plt.show()
